// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fsm_cckconfig_MN.proto

#ifndef PROTOBUF_INCLUDED_fsm_5fcckconfig_5fMN_2eproto
#define PROTOBUF_INCLUDED_fsm_5fcckconfig_5fMN_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "nanopb.pb.h"
#include "fsm_cckconfig_clientinfo.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_fsm_5fcckconfig_5fMN_2eproto 

namespace protobuf_fsm_5fcckconfig_5fMN_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_fsm_5fcckconfig_5fMN_2eproto
namespace fsm {
class MN;
class MNDefaultTypeInternal;
extern MNDefaultTypeInternal _MN_default_instance_;
class MN825_R168;
class MN825_R168DefaultTypeInternal;
extern MN825_R168DefaultTypeInternal _MN825_R168_default_instance_;
class MN825_R168C;
class MN825_R168CDefaultTypeInternal;
extern MN825_R168CDefaultTypeInternal _MN825_R168C_default_instance_;
class MN921_ATS;
class MN921_ATSDefaultTypeInternal;
extern MN921_ATSDefaultTypeInternal _MN921_ATS_default_instance_;
class MN921_CB;
class MN921_CBDefaultTypeInternal;
extern MN921_CBDefaultTypeInternal _MN921_CB_default_instance_;
class MN921_MB;
class MN921_MBDefaultTypeInternal;
extern MN921_MBDefaultTypeInternal _MN921_MB_default_instance_;
class MN921_TCH;
class MN921_TCHDefaultTypeInternal;
extern MN921_TCHDefaultTypeInternal _MN921_TCH_default_instance_;
class MN_Channel;
class MN_ChannelDefaultTypeInternal;
extern MN_ChannelDefaultTypeInternal _MN_Channel_default_instance_;
}  // namespace fsm
namespace google {
namespace protobuf {
template<> ::fsm::MN* Arena::CreateMaybeMessage<::fsm::MN>(Arena*);
template<> ::fsm::MN825_R168* Arena::CreateMaybeMessage<::fsm::MN825_R168>(Arena*);
template<> ::fsm::MN825_R168C* Arena::CreateMaybeMessage<::fsm::MN825_R168C>(Arena*);
template<> ::fsm::MN921_ATS* Arena::CreateMaybeMessage<::fsm::MN921_ATS>(Arena*);
template<> ::fsm::MN921_CB* Arena::CreateMaybeMessage<::fsm::MN921_CB>(Arena*);
template<> ::fsm::MN921_MB* Arena::CreateMaybeMessage<::fsm::MN921_MB>(Arena*);
template<> ::fsm::MN921_TCH* Arena::CreateMaybeMessage<::fsm::MN921_TCH>(Arena*);
template<> ::fsm::MN_Channel* Arena::CreateMaybeMessage<::fsm::MN_Channel>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace fsm {

enum MNTypeDevice {
  MB = 0,
  CB = 1,
  TCH = 2,
  ATS = 3,
  R168 = 4,
  R168100KB = 5,
  MNTypeDevice_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MNTypeDevice_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MNTypeDevice_IsValid(int value);
const MNTypeDevice MNTypeDevice_MIN = MB;
const MNTypeDevice MNTypeDevice_MAX = R168100KB;
const int MNTypeDevice_ARRAYSIZE = MNTypeDevice_MAX + 1;

const ::google::protobuf::EnumDescriptor* MNTypeDevice_descriptor();
inline const ::std::string& MNTypeDevice_Name(MNTypeDevice value) {
  return ::google::protobuf::internal::NameOfEnum(
    MNTypeDevice_descriptor(), value);
}
inline bool MNTypeDevice_Parse(
    const ::std::string& name, MNTypeDevice* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MNTypeDevice>(
    MNTypeDevice_descriptor(), name, value);
}
enum MN921TypeTCH {
  TwoWire = 0,
  FourWire_FL = 1,
  FourWire_TCH = 2,
  MN921TypeTCH_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MN921TypeTCH_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MN921TypeTCH_IsValid(int value);
const MN921TypeTCH MN921TypeTCH_MIN = TwoWire;
const MN921TypeTCH MN921TypeTCH_MAX = FourWire_TCH;
const int MN921TypeTCH_ARRAYSIZE = MN921TypeTCH_MAX + 1;

const ::google::protobuf::EnumDescriptor* MN921TypeTCH_descriptor();
inline const ::std::string& MN921TypeTCH_Name(MN921TypeTCH value) {
  return ::google::protobuf::internal::NameOfEnum(
    MN921TypeTCH_descriptor(), value);
}
inline bool MN921TypeTCH_Parse(
    const ::std::string& name, MN921TypeTCH* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MN921TypeTCH>(
    MN921TypeTCH_descriptor(), name, value);
}
enum MN921OutputCallFrequency {
  F_600 = 0,
  F_2100 = 1,
  MN921OutputCallFrequency_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MN921OutputCallFrequency_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MN921OutputCallFrequency_IsValid(int value);
const MN921OutputCallFrequency MN921OutputCallFrequency_MIN = F_600;
const MN921OutputCallFrequency MN921OutputCallFrequency_MAX = F_2100;
const int MN921OutputCallFrequency_ARRAYSIZE = MN921OutputCallFrequency_MAX + 1;

const ::google::protobuf::EnumDescriptor* MN921OutputCallFrequency_descriptor();
inline const ::std::string& MN921OutputCallFrequency_Name(MN921OutputCallFrequency value) {
  return ::google::protobuf::internal::NameOfEnum(
    MN921OutputCallFrequency_descriptor(), value);
}
inline bool MN921OutputCallFrequency_Parse(
    const ::std::string& name, MN921OutputCallFrequency* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MN921OutputCallFrequency>(
    MN921OutputCallFrequency_descriptor(), name, value);
}
enum MN921TypeATS {
  Pulse = 0,
  Tone = 1,
  MN921TypeATS_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MN921TypeATS_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MN921TypeATS_IsValid(int value);
const MN921TypeATS MN921TypeATS_MIN = Pulse;
const MN921TypeATS MN921TypeATS_MAX = Tone;
const int MN921TypeATS_ARRAYSIZE = MN921TypeATS_MAX + 1;

const ::google::protobuf::EnumDescriptor* MN921TypeATS_descriptor();
inline const ::std::string& MN921TypeATS_Name(MN921TypeATS value) {
  return ::google::protobuf::internal::NameOfEnum(
    MN921TypeATS_descriptor(), value);
}
inline bool MN921TypeATS_Parse(
    const ::std::string& name, MN921TypeATS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MN921TypeATS>(
    MN921TypeATS_descriptor(), name, value);
}
// ===================================================================

class MN921_MB : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fsm.MN921_MB) */ {
 public:
  MN921_MB();
  virtual ~MN921_MB();

  MN921_MB(const MN921_MB& from);

  inline MN921_MB& operator=(const MN921_MB& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MN921_MB(MN921_MB&& from) noexcept
    : MN921_MB() {
    *this = ::std::move(from);
  }

  inline MN921_MB& operator=(MN921_MB&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MN921_MB& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MN921_MB* internal_default_instance() {
    return reinterpret_cast<const MN921_MB*>(
               &_MN921_MB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(MN921_MB* other);
  friend void swap(MN921_MB& a, MN921_MB& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MN921_MB* New() const final {
    return CreateMaybeMessage<MN921_MB>(NULL);
  }

  MN921_MB* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MN921_MB>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MN921_MB& from);
  void MergeFrom(const MN921_MB& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MN921_MB* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 TimeOutputCall = 1;
  void clear_timeoutputcall();
  static const int kTimeOutputCallFieldNumber = 1;
  ::google::protobuf::uint32 timeoutputcall() const;
  void set_timeoutputcall(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fsm.MN921_MB)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 timeoutputcall_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_fsm_5fcckconfig_5fMN_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MN921_CB : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fsm.MN921_CB) */ {
 public:
  MN921_CB();
  virtual ~MN921_CB();

  MN921_CB(const MN921_CB& from);

  inline MN921_CB& operator=(const MN921_CB& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MN921_CB(MN921_CB&& from) noexcept
    : MN921_CB() {
    *this = ::std::move(from);
  }

  inline MN921_CB& operator=(MN921_CB&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MN921_CB& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MN921_CB* internal_default_instance() {
    return reinterpret_cast<const MN921_CB*>(
               &_MN921_CB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(MN921_CB* other);
  friend void swap(MN921_CB& a, MN921_CB& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MN921_CB* New() const final {
    return CreateMaybeMessage<MN921_CB>(NULL);
  }

  MN921_CB* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MN921_CB>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MN921_CB& from);
  void MergeFrom(const MN921_CB& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MN921_CB* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 TimeOutputCall = 1;
  void clear_timeoutputcall();
  static const int kTimeOutputCallFieldNumber = 1;
  ::google::protobuf::uint32 timeoutputcall() const;
  void set_timeoutputcall(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fsm.MN921_CB)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 timeoutputcall_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_fsm_5fcckconfig_5fMN_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MN921_TCH : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fsm.MN921_TCH) */ {
 public:
  MN921_TCH();
  virtual ~MN921_TCH();

  MN921_TCH(const MN921_TCH& from);

  inline MN921_TCH& operator=(const MN921_TCH& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MN921_TCH(MN921_TCH&& from) noexcept
    : MN921_TCH() {
    *this = ::std::move(from);
  }

  inline MN921_TCH& operator=(MN921_TCH&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MN921_TCH& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MN921_TCH* internal_default_instance() {
    return reinterpret_cast<const MN921_TCH*>(
               &_MN921_TCH_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(MN921_TCH* other);
  friend void swap(MN921_TCH& a, MN921_TCH& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MN921_TCH* New() const final {
    return CreateMaybeMessage<MN921_TCH>(NULL);
  }

  MN921_TCH* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MN921_TCH>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MN921_TCH& from);
  void MergeFrom(const MN921_TCH& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MN921_TCH* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .fsm.MN921TypeTCH typetch = 1;
  void clear_typetch();
  static const int kTypetchFieldNumber = 1;
  ::fsm::MN921TypeTCH typetch() const;
  void set_typetch(::fsm::MN921TypeTCH value);

  // uint32 TimeOutputCall = 2;
  void clear_timeoutputcall();
  static const int kTimeOutputCallFieldNumber = 2;
  ::google::protobuf::uint32 timeoutputcall() const;
  void set_timeoutputcall(::google::protobuf::uint32 value);

  // uint32 MinTimeOutputCall = 3;
  void clear_mintimeoutputcall();
  static const int kMinTimeOutputCallFieldNumber = 3;
  ::google::protobuf::uint32 mintimeoutputcall() const;
  void set_mintimeoutputcall(::google::protobuf::uint32 value);

  // uint32 MaxTimeOutputCall = 4;
  void clear_maxtimeoutputcall();
  static const int kMaxTimeOutputCallFieldNumber = 4;
  ::google::protobuf::uint32 maxtimeoutputcall() const;
  void set_maxtimeoutputcall(::google::protobuf::uint32 value);

  // .fsm.MN921OutputCallFrequency ocfr = 5;
  void clear_ocfr();
  static const int kOcfrFieldNumber = 5;
  ::fsm::MN921OutputCallFrequency ocfr() const;
  void set_ocfr(::fsm::MN921OutputCallFrequency value);

  // @@protoc_insertion_point(class_scope:fsm.MN921_TCH)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int typetch_;
  ::google::protobuf::uint32 timeoutputcall_;
  ::google::protobuf::uint32 mintimeoutputcall_;
  ::google::protobuf::uint32 maxtimeoutputcall_;
  int ocfr_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_fsm_5fcckconfig_5fMN_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MN921_ATS : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fsm.MN921_ATS) */ {
 public:
  MN921_ATS();
  virtual ~MN921_ATS();

  MN921_ATS(const MN921_ATS& from);

  inline MN921_ATS& operator=(const MN921_ATS& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MN921_ATS(MN921_ATS&& from) noexcept
    : MN921_ATS() {
    *this = ::std::move(from);
  }

  inline MN921_ATS& operator=(MN921_ATS&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MN921_ATS& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MN921_ATS* internal_default_instance() {
    return reinterpret_cast<const MN921_ATS*>(
               &_MN921_ATS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(MN921_ATS* other);
  friend void swap(MN921_ATS& a, MN921_ATS& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MN921_ATS* New() const final {
    return CreateMaybeMessage<MN921_ATS>(NULL);
  }

  MN921_ATS* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MN921_ATS>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MN921_ATS& from);
  void MergeFrom(const MN921_ATS& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MN921_ATS* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .fsm.MN921TypeATS typeats = 1;
  void clear_typeats();
  static const int kTypeatsFieldNumber = 1;
  ::fsm::MN921TypeATS typeats() const;
  void set_typeats(::fsm::MN921TypeATS value);

  // @@protoc_insertion_point(class_scope:fsm.MN921_ATS)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int typeats_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_fsm_5fcckconfig_5fMN_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MN825_R168C : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fsm.MN825_R168C) */ {
 public:
  MN825_R168C();
  virtual ~MN825_R168C();

  MN825_R168C(const MN825_R168C& from);

  inline MN825_R168C& operator=(const MN825_R168C& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MN825_R168C(MN825_R168C&& from) noexcept
    : MN825_R168C() {
    *this = ::std::move(from);
  }

  inline MN825_R168C& operator=(MN825_R168C&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MN825_R168C& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MN825_R168C* internal_default_instance() {
    return reinterpret_cast<const MN825_R168C*>(
               &_MN825_R168C_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(MN825_R168C* other);
  friend void swap(MN825_R168C& a, MN825_R168C& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MN825_R168C* New() const final {
    return CreateMaybeMessage<MN825_R168C>(NULL);
  }

  MN825_R168C* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MN825_R168C>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MN825_R168C& from);
  void MergeFrom(const MN825_R168C& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MN825_R168C* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 TimeOutputCall = 1;
  void clear_timeoutputcall();
  static const int kTimeOutputCallFieldNumber = 1;
  ::google::protobuf::uint32 timeoutputcall() const;
  void set_timeoutputcall(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fsm.MN825_R168C)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 timeoutputcall_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_fsm_5fcckconfig_5fMN_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MN_Channel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fsm.MN_Channel) */ {
 public:
  MN_Channel();
  virtual ~MN_Channel();

  MN_Channel(const MN_Channel& from);

  inline MN_Channel& operator=(const MN_Channel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MN_Channel(MN_Channel&& from) noexcept
    : MN_Channel() {
    *this = ::std::move(from);
  }

  inline MN_Channel& operator=(MN_Channel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MN_Channel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MN_Channel* internal_default_instance() {
    return reinterpret_cast<const MN_Channel*>(
               &_MN_Channel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(MN_Channel* other);
  friend void swap(MN_Channel& a, MN_Channel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MN_Channel* New() const final {
    return CreateMaybeMessage<MN_Channel>(NULL);
  }

  MN_Channel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MN_Channel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MN_Channel& from);
  void MergeFrom(const MN_Channel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MN_Channel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 SubscriberForCall = 6 [(.nanopb) = {
  int subscriberforcall_size() const;
  void clear_subscriberforcall();
  static const int kSubscriberForCallFieldNumber = 6;
  ::google::protobuf::uint32 subscriberforcall(int index) const;
  void set_subscriberforcall(int index, ::google::protobuf::uint32 value);
  void add_subscriberforcall(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      subscriberforcall() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_subscriberforcall();

  // .fsm.MN921_MB mb = 7;
  bool has_mb() const;
  void clear_mb();
  static const int kMbFieldNumber = 7;
  private:
  const ::fsm::MN921_MB& _internal_mb() const;
  public:
  const ::fsm::MN921_MB& mb() const;
  ::fsm::MN921_MB* release_mb();
  ::fsm::MN921_MB* mutable_mb();
  void set_allocated_mb(::fsm::MN921_MB* mb);

  // .fsm.MN921_CB cb = 8;
  bool has_cb() const;
  void clear_cb();
  static const int kCbFieldNumber = 8;
  private:
  const ::fsm::MN921_CB& _internal_cb() const;
  public:
  const ::fsm::MN921_CB& cb() const;
  ::fsm::MN921_CB* release_cb();
  ::fsm::MN921_CB* mutable_cb();
  void set_allocated_cb(::fsm::MN921_CB* cb);

  // .fsm.MN921_TCH tch = 9;
  bool has_tch() const;
  void clear_tch();
  static const int kTchFieldNumber = 9;
  private:
  const ::fsm::MN921_TCH& _internal_tch() const;
  public:
  const ::fsm::MN921_TCH& tch() const;
  ::fsm::MN921_TCH* release_tch();
  ::fsm::MN921_TCH* mutable_tch();
  void set_allocated_tch(::fsm::MN921_TCH* tch);

  // .fsm.MN921_ATS ats = 10;
  bool has_ats() const;
  void clear_ats();
  static const int kAtsFieldNumber = 10;
  private:
  const ::fsm::MN921_ATS& _internal_ats() const;
  public:
  const ::fsm::MN921_ATS& ats() const;
  ::fsm::MN921_ATS* release_ats();
  ::fsm::MN921_ATS* mutable_ats();
  void set_allocated_ats(::fsm::MN921_ATS* ats);

  // .fsm.MN825_R168C r168 = 11;
  bool has_r168() const;
  void clear_r168();
  static const int kR168FieldNumber = 11;
  private:
  const ::fsm::MN825_R168C& _internal_r168() const;
  public:
  const ::fsm::MN825_R168C& r168() const;
  ::fsm::MN825_R168C* release_r168();
  ::fsm::MN825_R168C* mutable_r168();
  void set_allocated_r168(::fsm::MN825_R168C* r168);

  // uint32 self_sip_port = 1;
  void clear_self_sip_port();
  static const int kSelfSipPortFieldNumber = 1;
  ::google::protobuf::uint32 self_sip_port() const;
  void set_self_sip_port(::google::protobuf::uint32 value);

  // uint32 self_rtp_port = 2;
  void clear_self_rtp_port();
  static const int kSelfRtpPortFieldNumber = 2;
  ::google::protobuf::uint32 self_rtp_port() const;
  void set_self_rtp_port(::google::protobuf::uint32 value);

  // uint32 self_sip_number = 3;
  void clear_self_sip_number();
  static const int kSelfSipNumberFieldNumber = 3;
  ::google::protobuf::uint32 self_sip_number() const;
  void set_self_sip_number(::google::protobuf::uint32 value);

  // uint32 volume = 4;
  void clear_volume();
  static const int kVolumeFieldNumber = 4;
  ::google::protobuf::uint32 volume() const;
  void set_volume(::google::protobuf::uint32 value);

  // .fsm.MNTypeDevice typedev = 5;
  void clear_typedev();
  static const int kTypedevFieldNumber = 5;
  ::fsm::MNTypeDevice typedev() const;
  void set_typedev(::fsm::MNTypeDevice value);

  // @@protoc_insertion_point(class_scope:fsm.MN_Channel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > subscriberforcall_;
  mutable int _subscriberforcall_cached_byte_size_;
  ::fsm::MN921_MB* mb_;
  ::fsm::MN921_CB* cb_;
  ::fsm::MN921_TCH* tch_;
  ::fsm::MN921_ATS* ats_;
  ::fsm::MN825_R168C* r168_;
  ::google::protobuf::uint32 self_sip_port_;
  ::google::protobuf::uint32 self_rtp_port_;
  ::google::protobuf::uint32 self_sip_number_;
  ::google::protobuf::uint32 volume_;
  int typedev_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_fsm_5fcckconfig_5fMN_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MN825_R168 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fsm.MN825_R168) */ {
 public:
  MN825_R168();
  virtual ~MN825_R168();

  MN825_R168(const MN825_R168& from);

  inline MN825_R168& operator=(const MN825_R168& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MN825_R168(MN825_R168&& from) noexcept
    : MN825_R168() {
    *this = ::std::move(from);
  }

  inline MN825_R168& operator=(MN825_R168&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MN825_R168& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MN825_R168* internal_default_instance() {
    return reinterpret_cast<const MN825_R168*>(
               &_MN825_R168_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(MN825_R168* other);
  friend void swap(MN825_R168& a, MN825_R168& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MN825_R168* New() const final {
    return CreateMaybeMessage<MN825_R168>(NULL);
  }

  MN825_R168* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MN825_R168>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MN825_R168& from);
  void MergeFrom(const MN825_R168& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MN825_R168* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 r168port = 1;
  void clear_r168port();
  static const int kR168PortFieldNumber = 1;
  ::google::protobuf::uint32 r168port() const;
  void set_r168port(::google::protobuf::uint32 value);

  // uint32 apd = 2;
  void clear_apd();
  static const int kApdFieldNumber = 2;
  ::google::protobuf::uint32 apd() const;
  void set_apd(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fsm.MN825_R168)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 r168port_;
  ::google::protobuf::uint32 apd_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_fsm_5fcckconfig_5fMN_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MN : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fsm.MN) */ {
 public:
  MN();
  virtual ~MN();

  MN(const MN& from);

  inline MN& operator=(const MN& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MN(MN&& from) noexcept
    : MN() {
    *this = ::std::move(from);
  }

  inline MN& operator=(MN&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MN& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MN* internal_default_instance() {
    return reinterpret_cast<const MN*>(
               &_MN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(MN* other);
  friend void swap(MN& a, MN& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MN* New() const final {
    return CreateMaybeMessage<MN>(NULL);
  }

  MN* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MN>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MN& from);
  void MergeFrom(const MN& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MN* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fsm.MN_Channel channel = 3 [(.nanopb) = {
  int channel_size() const;
  void clear_channel();
  static const int kChannelFieldNumber = 3;
  ::fsm::MN_Channel* mutable_channel(int index);
  ::google::protobuf::RepeatedPtrField< ::fsm::MN_Channel >*
      mutable_channel();
  const ::fsm::MN_Channel& channel(int index) const;
  ::fsm::MN_Channel* add_channel();
  const ::google::protobuf::RepeatedPtrField< ::fsm::MN_Channel >&
      channel() const;

  // .fsm.ClientInfo client = 1;
  bool has_client() const;
  void clear_client();
  static const int kClientFieldNumber = 1;
  private:
  const ::fsm::ClientInfo& _internal_client() const;
  public:
  const ::fsm::ClientInfo& client() const;
  ::fsm::ClientInfo* release_client();
  ::fsm::ClientInfo* mutable_client();
  void set_allocated_client(::fsm::ClientInfo* client);

  // .fsm.MN825_R168 r168 = 2;
  bool has_r168() const;
  void clear_r168();
  static const int kR168FieldNumber = 2;
  private:
  const ::fsm::MN825_R168& _internal_r168() const;
  public:
  const ::fsm::MN825_R168& r168() const;
  ::fsm::MN825_R168* release_r168();
  ::fsm::MN825_R168* mutable_r168();
  void set_allocated_r168(::fsm::MN825_R168* r168);

  // @@protoc_insertion_point(class_scope:fsm.MN)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::fsm::MN_Channel > channel_;
  ::fsm::ClientInfo* client_;
  ::fsm::MN825_R168* r168_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_fsm_5fcckconfig_5fMN_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MN921_MB

// uint32 TimeOutputCall = 1;
inline void MN921_MB::clear_timeoutputcall() {
  timeoutputcall_ = 0u;
}
inline ::google::protobuf::uint32 MN921_MB::timeoutputcall() const {
  // @@protoc_insertion_point(field_get:fsm.MN921_MB.TimeOutputCall)
  return timeoutputcall_;
}
inline void MN921_MB::set_timeoutputcall(::google::protobuf::uint32 value) {
  
  timeoutputcall_ = value;
  // @@protoc_insertion_point(field_set:fsm.MN921_MB.TimeOutputCall)
}

// -------------------------------------------------------------------

// MN921_CB

// uint32 TimeOutputCall = 1;
inline void MN921_CB::clear_timeoutputcall() {
  timeoutputcall_ = 0u;
}
inline ::google::protobuf::uint32 MN921_CB::timeoutputcall() const {
  // @@protoc_insertion_point(field_get:fsm.MN921_CB.TimeOutputCall)
  return timeoutputcall_;
}
inline void MN921_CB::set_timeoutputcall(::google::protobuf::uint32 value) {
  
  timeoutputcall_ = value;
  // @@protoc_insertion_point(field_set:fsm.MN921_CB.TimeOutputCall)
}

// -------------------------------------------------------------------

// MN921_TCH

// .fsm.MN921TypeTCH typetch = 1;
inline void MN921_TCH::clear_typetch() {
  typetch_ = 0;
}
inline ::fsm::MN921TypeTCH MN921_TCH::typetch() const {
  // @@protoc_insertion_point(field_get:fsm.MN921_TCH.typetch)
  return static_cast< ::fsm::MN921TypeTCH >(typetch_);
}
inline void MN921_TCH::set_typetch(::fsm::MN921TypeTCH value) {
  
  typetch_ = value;
  // @@protoc_insertion_point(field_set:fsm.MN921_TCH.typetch)
}

// uint32 TimeOutputCall = 2;
inline void MN921_TCH::clear_timeoutputcall() {
  timeoutputcall_ = 0u;
}
inline ::google::protobuf::uint32 MN921_TCH::timeoutputcall() const {
  // @@protoc_insertion_point(field_get:fsm.MN921_TCH.TimeOutputCall)
  return timeoutputcall_;
}
inline void MN921_TCH::set_timeoutputcall(::google::protobuf::uint32 value) {
  
  timeoutputcall_ = value;
  // @@protoc_insertion_point(field_set:fsm.MN921_TCH.TimeOutputCall)
}

// uint32 MinTimeOutputCall = 3;
inline void MN921_TCH::clear_mintimeoutputcall() {
  mintimeoutputcall_ = 0u;
}
inline ::google::protobuf::uint32 MN921_TCH::mintimeoutputcall() const {
  // @@protoc_insertion_point(field_get:fsm.MN921_TCH.MinTimeOutputCall)
  return mintimeoutputcall_;
}
inline void MN921_TCH::set_mintimeoutputcall(::google::protobuf::uint32 value) {
  
  mintimeoutputcall_ = value;
  // @@protoc_insertion_point(field_set:fsm.MN921_TCH.MinTimeOutputCall)
}

// uint32 MaxTimeOutputCall = 4;
inline void MN921_TCH::clear_maxtimeoutputcall() {
  maxtimeoutputcall_ = 0u;
}
inline ::google::protobuf::uint32 MN921_TCH::maxtimeoutputcall() const {
  // @@protoc_insertion_point(field_get:fsm.MN921_TCH.MaxTimeOutputCall)
  return maxtimeoutputcall_;
}
inline void MN921_TCH::set_maxtimeoutputcall(::google::protobuf::uint32 value) {
  
  maxtimeoutputcall_ = value;
  // @@protoc_insertion_point(field_set:fsm.MN921_TCH.MaxTimeOutputCall)
}

// .fsm.MN921OutputCallFrequency ocfr = 5;
inline void MN921_TCH::clear_ocfr() {
  ocfr_ = 0;
}
inline ::fsm::MN921OutputCallFrequency MN921_TCH::ocfr() const {
  // @@protoc_insertion_point(field_get:fsm.MN921_TCH.ocfr)
  return static_cast< ::fsm::MN921OutputCallFrequency >(ocfr_);
}
inline void MN921_TCH::set_ocfr(::fsm::MN921OutputCallFrequency value) {
  
  ocfr_ = value;
  // @@protoc_insertion_point(field_set:fsm.MN921_TCH.ocfr)
}

// -------------------------------------------------------------------

// MN921_ATS

// .fsm.MN921TypeATS typeats = 1;
inline void MN921_ATS::clear_typeats() {
  typeats_ = 0;
}
inline ::fsm::MN921TypeATS MN921_ATS::typeats() const {
  // @@protoc_insertion_point(field_get:fsm.MN921_ATS.typeats)
  return static_cast< ::fsm::MN921TypeATS >(typeats_);
}
inline void MN921_ATS::set_typeats(::fsm::MN921TypeATS value) {
  
  typeats_ = value;
  // @@protoc_insertion_point(field_set:fsm.MN921_ATS.typeats)
}

// -------------------------------------------------------------------

// MN825_R168C

// uint32 TimeOutputCall = 1;
inline void MN825_R168C::clear_timeoutputcall() {
  timeoutputcall_ = 0u;
}
inline ::google::protobuf::uint32 MN825_R168C::timeoutputcall() const {
  // @@protoc_insertion_point(field_get:fsm.MN825_R168C.TimeOutputCall)
  return timeoutputcall_;
}
inline void MN825_R168C::set_timeoutputcall(::google::protobuf::uint32 value) {
  
  timeoutputcall_ = value;
  // @@protoc_insertion_point(field_set:fsm.MN825_R168C.TimeOutputCall)
}

// -------------------------------------------------------------------

// MN_Channel

// uint32 self_sip_port = 1;
inline void MN_Channel::clear_self_sip_port() {
  self_sip_port_ = 0u;
}
inline ::google::protobuf::uint32 MN_Channel::self_sip_port() const {
  // @@protoc_insertion_point(field_get:fsm.MN_Channel.self_sip_port)
  return self_sip_port_;
}
inline void MN_Channel::set_self_sip_port(::google::protobuf::uint32 value) {
  
  self_sip_port_ = value;
  // @@protoc_insertion_point(field_set:fsm.MN_Channel.self_sip_port)
}

// uint32 self_rtp_port = 2;
inline void MN_Channel::clear_self_rtp_port() {
  self_rtp_port_ = 0u;
}
inline ::google::protobuf::uint32 MN_Channel::self_rtp_port() const {
  // @@protoc_insertion_point(field_get:fsm.MN_Channel.self_rtp_port)
  return self_rtp_port_;
}
inline void MN_Channel::set_self_rtp_port(::google::protobuf::uint32 value) {
  
  self_rtp_port_ = value;
  // @@protoc_insertion_point(field_set:fsm.MN_Channel.self_rtp_port)
}

// uint32 self_sip_number = 3;
inline void MN_Channel::clear_self_sip_number() {
  self_sip_number_ = 0u;
}
inline ::google::protobuf::uint32 MN_Channel::self_sip_number() const {
  // @@protoc_insertion_point(field_get:fsm.MN_Channel.self_sip_number)
  return self_sip_number_;
}
inline void MN_Channel::set_self_sip_number(::google::protobuf::uint32 value) {
  
  self_sip_number_ = value;
  // @@protoc_insertion_point(field_set:fsm.MN_Channel.self_sip_number)
}

// uint32 volume = 4;
inline void MN_Channel::clear_volume() {
  volume_ = 0u;
}
inline ::google::protobuf::uint32 MN_Channel::volume() const {
  // @@protoc_insertion_point(field_get:fsm.MN_Channel.volume)
  return volume_;
}
inline void MN_Channel::set_volume(::google::protobuf::uint32 value) {
  
  volume_ = value;
  // @@protoc_insertion_point(field_set:fsm.MN_Channel.volume)
}

// .fsm.MNTypeDevice typedev = 5;
inline void MN_Channel::clear_typedev() {
  typedev_ = 0;
}
inline ::fsm::MNTypeDevice MN_Channel::typedev() const {
  // @@protoc_insertion_point(field_get:fsm.MN_Channel.typedev)
  return static_cast< ::fsm::MNTypeDevice >(typedev_);
}
inline void MN_Channel::set_typedev(::fsm::MNTypeDevice value) {
  
  typedev_ = value;
  // @@protoc_insertion_point(field_set:fsm.MN_Channel.typedev)
}

// repeated uint32 SubscriberForCall = 6 [(.nanopb) = {
inline int MN_Channel::subscriberforcall_size() const {
  return subscriberforcall_.size();
}
inline void MN_Channel::clear_subscriberforcall() {
  subscriberforcall_.Clear();
}
inline ::google::protobuf::uint32 MN_Channel::subscriberforcall(int index) const {
  // @@protoc_insertion_point(field_get:fsm.MN_Channel.SubscriberForCall)
  return subscriberforcall_.Get(index);
}
inline void MN_Channel::set_subscriberforcall(int index, ::google::protobuf::uint32 value) {
  subscriberforcall_.Set(index, value);
  // @@protoc_insertion_point(field_set:fsm.MN_Channel.SubscriberForCall)
}
inline void MN_Channel::add_subscriberforcall(::google::protobuf::uint32 value) {
  subscriberforcall_.Add(value);
  // @@protoc_insertion_point(field_add:fsm.MN_Channel.SubscriberForCall)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MN_Channel::subscriberforcall() const {
  // @@protoc_insertion_point(field_list:fsm.MN_Channel.SubscriberForCall)
  return subscriberforcall_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MN_Channel::mutable_subscriberforcall() {
  // @@protoc_insertion_point(field_mutable_list:fsm.MN_Channel.SubscriberForCall)
  return &subscriberforcall_;
}

// .fsm.MN921_MB mb = 7;
inline bool MN_Channel::has_mb() const {
  return this != internal_default_instance() && mb_ != NULL;
}
inline void MN_Channel::clear_mb() {
  if (GetArenaNoVirtual() == NULL && mb_ != NULL) {
    delete mb_;
  }
  mb_ = NULL;
}
inline const ::fsm::MN921_MB& MN_Channel::_internal_mb() const {
  return *mb_;
}
inline const ::fsm::MN921_MB& MN_Channel::mb() const {
  const ::fsm::MN921_MB* p = mb_;
  // @@protoc_insertion_point(field_get:fsm.MN_Channel.mb)
  return p != NULL ? *p : *reinterpret_cast<const ::fsm::MN921_MB*>(
      &::fsm::_MN921_MB_default_instance_);
}
inline ::fsm::MN921_MB* MN_Channel::release_mb() {
  // @@protoc_insertion_point(field_release:fsm.MN_Channel.mb)
  
  ::fsm::MN921_MB* temp = mb_;
  mb_ = NULL;
  return temp;
}
inline ::fsm::MN921_MB* MN_Channel::mutable_mb() {
  
  if (mb_ == NULL) {
    auto* p = CreateMaybeMessage<::fsm::MN921_MB>(GetArenaNoVirtual());
    mb_ = p;
  }
  // @@protoc_insertion_point(field_mutable:fsm.MN_Channel.mb)
  return mb_;
}
inline void MN_Channel::set_allocated_mb(::fsm::MN921_MB* mb) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete mb_;
  }
  if (mb) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      mb = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mb, submessage_arena);
    }
    
  } else {
    
  }
  mb_ = mb;
  // @@protoc_insertion_point(field_set_allocated:fsm.MN_Channel.mb)
}

// .fsm.MN921_CB cb = 8;
inline bool MN_Channel::has_cb() const {
  return this != internal_default_instance() && cb_ != NULL;
}
inline void MN_Channel::clear_cb() {
  if (GetArenaNoVirtual() == NULL && cb_ != NULL) {
    delete cb_;
  }
  cb_ = NULL;
}
inline const ::fsm::MN921_CB& MN_Channel::_internal_cb() const {
  return *cb_;
}
inline const ::fsm::MN921_CB& MN_Channel::cb() const {
  const ::fsm::MN921_CB* p = cb_;
  // @@protoc_insertion_point(field_get:fsm.MN_Channel.cb)
  return p != NULL ? *p : *reinterpret_cast<const ::fsm::MN921_CB*>(
      &::fsm::_MN921_CB_default_instance_);
}
inline ::fsm::MN921_CB* MN_Channel::release_cb() {
  // @@protoc_insertion_point(field_release:fsm.MN_Channel.cb)
  
  ::fsm::MN921_CB* temp = cb_;
  cb_ = NULL;
  return temp;
}
inline ::fsm::MN921_CB* MN_Channel::mutable_cb() {
  
  if (cb_ == NULL) {
    auto* p = CreateMaybeMessage<::fsm::MN921_CB>(GetArenaNoVirtual());
    cb_ = p;
  }
  // @@protoc_insertion_point(field_mutable:fsm.MN_Channel.cb)
  return cb_;
}
inline void MN_Channel::set_allocated_cb(::fsm::MN921_CB* cb) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cb_;
  }
  if (cb) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cb = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cb, submessage_arena);
    }
    
  } else {
    
  }
  cb_ = cb;
  // @@protoc_insertion_point(field_set_allocated:fsm.MN_Channel.cb)
}

// .fsm.MN921_TCH tch = 9;
inline bool MN_Channel::has_tch() const {
  return this != internal_default_instance() && tch_ != NULL;
}
inline void MN_Channel::clear_tch() {
  if (GetArenaNoVirtual() == NULL && tch_ != NULL) {
    delete tch_;
  }
  tch_ = NULL;
}
inline const ::fsm::MN921_TCH& MN_Channel::_internal_tch() const {
  return *tch_;
}
inline const ::fsm::MN921_TCH& MN_Channel::tch() const {
  const ::fsm::MN921_TCH* p = tch_;
  // @@protoc_insertion_point(field_get:fsm.MN_Channel.tch)
  return p != NULL ? *p : *reinterpret_cast<const ::fsm::MN921_TCH*>(
      &::fsm::_MN921_TCH_default_instance_);
}
inline ::fsm::MN921_TCH* MN_Channel::release_tch() {
  // @@protoc_insertion_point(field_release:fsm.MN_Channel.tch)
  
  ::fsm::MN921_TCH* temp = tch_;
  tch_ = NULL;
  return temp;
}
inline ::fsm::MN921_TCH* MN_Channel::mutable_tch() {
  
  if (tch_ == NULL) {
    auto* p = CreateMaybeMessage<::fsm::MN921_TCH>(GetArenaNoVirtual());
    tch_ = p;
  }
  // @@protoc_insertion_point(field_mutable:fsm.MN_Channel.tch)
  return tch_;
}
inline void MN_Channel::set_allocated_tch(::fsm::MN921_TCH* tch) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tch_;
  }
  if (tch) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tch = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tch, submessage_arena);
    }
    
  } else {
    
  }
  tch_ = tch;
  // @@protoc_insertion_point(field_set_allocated:fsm.MN_Channel.tch)
}

// .fsm.MN921_ATS ats = 10;
inline bool MN_Channel::has_ats() const {
  return this != internal_default_instance() && ats_ != NULL;
}
inline void MN_Channel::clear_ats() {
  if (GetArenaNoVirtual() == NULL && ats_ != NULL) {
    delete ats_;
  }
  ats_ = NULL;
}
inline const ::fsm::MN921_ATS& MN_Channel::_internal_ats() const {
  return *ats_;
}
inline const ::fsm::MN921_ATS& MN_Channel::ats() const {
  const ::fsm::MN921_ATS* p = ats_;
  // @@protoc_insertion_point(field_get:fsm.MN_Channel.ats)
  return p != NULL ? *p : *reinterpret_cast<const ::fsm::MN921_ATS*>(
      &::fsm::_MN921_ATS_default_instance_);
}
inline ::fsm::MN921_ATS* MN_Channel::release_ats() {
  // @@protoc_insertion_point(field_release:fsm.MN_Channel.ats)
  
  ::fsm::MN921_ATS* temp = ats_;
  ats_ = NULL;
  return temp;
}
inline ::fsm::MN921_ATS* MN_Channel::mutable_ats() {
  
  if (ats_ == NULL) {
    auto* p = CreateMaybeMessage<::fsm::MN921_ATS>(GetArenaNoVirtual());
    ats_ = p;
  }
  // @@protoc_insertion_point(field_mutable:fsm.MN_Channel.ats)
  return ats_;
}
inline void MN_Channel::set_allocated_ats(::fsm::MN921_ATS* ats) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ats_;
  }
  if (ats) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ats = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ats, submessage_arena);
    }
    
  } else {
    
  }
  ats_ = ats;
  // @@protoc_insertion_point(field_set_allocated:fsm.MN_Channel.ats)
}

// .fsm.MN825_R168C r168 = 11;
inline bool MN_Channel::has_r168() const {
  return this != internal_default_instance() && r168_ != NULL;
}
inline void MN_Channel::clear_r168() {
  if (GetArenaNoVirtual() == NULL && r168_ != NULL) {
    delete r168_;
  }
  r168_ = NULL;
}
inline const ::fsm::MN825_R168C& MN_Channel::_internal_r168() const {
  return *r168_;
}
inline const ::fsm::MN825_R168C& MN_Channel::r168() const {
  const ::fsm::MN825_R168C* p = r168_;
  // @@protoc_insertion_point(field_get:fsm.MN_Channel.r168)
  return p != NULL ? *p : *reinterpret_cast<const ::fsm::MN825_R168C*>(
      &::fsm::_MN825_R168C_default_instance_);
}
inline ::fsm::MN825_R168C* MN_Channel::release_r168() {
  // @@protoc_insertion_point(field_release:fsm.MN_Channel.r168)
  
  ::fsm::MN825_R168C* temp = r168_;
  r168_ = NULL;
  return temp;
}
inline ::fsm::MN825_R168C* MN_Channel::mutable_r168() {
  
  if (r168_ == NULL) {
    auto* p = CreateMaybeMessage<::fsm::MN825_R168C>(GetArenaNoVirtual());
    r168_ = p;
  }
  // @@protoc_insertion_point(field_mutable:fsm.MN_Channel.r168)
  return r168_;
}
inline void MN_Channel::set_allocated_r168(::fsm::MN825_R168C* r168) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete r168_;
  }
  if (r168) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      r168 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, r168, submessage_arena);
    }
    
  } else {
    
  }
  r168_ = r168;
  // @@protoc_insertion_point(field_set_allocated:fsm.MN_Channel.r168)
}

// -------------------------------------------------------------------

// MN825_R168

// uint32 r168port = 1;
inline void MN825_R168::clear_r168port() {
  r168port_ = 0u;
}
inline ::google::protobuf::uint32 MN825_R168::r168port() const {
  // @@protoc_insertion_point(field_get:fsm.MN825_R168.r168port)
  return r168port_;
}
inline void MN825_R168::set_r168port(::google::protobuf::uint32 value) {
  
  r168port_ = value;
  // @@protoc_insertion_point(field_set:fsm.MN825_R168.r168port)
}

// uint32 apd = 2;
inline void MN825_R168::clear_apd() {
  apd_ = 0u;
}
inline ::google::protobuf::uint32 MN825_R168::apd() const {
  // @@protoc_insertion_point(field_get:fsm.MN825_R168.apd)
  return apd_;
}
inline void MN825_R168::set_apd(::google::protobuf::uint32 value) {
  
  apd_ = value;
  // @@protoc_insertion_point(field_set:fsm.MN825_R168.apd)
}

// -------------------------------------------------------------------

// MN

// .fsm.ClientInfo client = 1;
inline bool MN::has_client() const {
  return this != internal_default_instance() && client_ != NULL;
}
inline const ::fsm::ClientInfo& MN::_internal_client() const {
  return *client_;
}
inline const ::fsm::ClientInfo& MN::client() const {
  const ::fsm::ClientInfo* p = client_;
  // @@protoc_insertion_point(field_get:fsm.MN.client)
  return p != NULL ? *p : *reinterpret_cast<const ::fsm::ClientInfo*>(
      &::fsm::_ClientInfo_default_instance_);
}
inline ::fsm::ClientInfo* MN::release_client() {
  // @@protoc_insertion_point(field_release:fsm.MN.client)
  
  ::fsm::ClientInfo* temp = client_;
  client_ = NULL;
  return temp;
}
inline ::fsm::ClientInfo* MN::mutable_client() {
  
  if (client_ == NULL) {
    auto* p = CreateMaybeMessage<::fsm::ClientInfo>(GetArenaNoVirtual());
    client_ = p;
  }
  // @@protoc_insertion_point(field_mutable:fsm.MN.client)
  return client_;
}
inline void MN::set_allocated_client(::fsm::ClientInfo* client) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(client_);
  }
  if (client) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      client = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, client, submessage_arena);
    }
    
  } else {
    
  }
  client_ = client;
  // @@protoc_insertion_point(field_set_allocated:fsm.MN.client)
}

// .fsm.MN825_R168 r168 = 2;
inline bool MN::has_r168() const {
  return this != internal_default_instance() && r168_ != NULL;
}
inline void MN::clear_r168() {
  if (GetArenaNoVirtual() == NULL && r168_ != NULL) {
    delete r168_;
  }
  r168_ = NULL;
}
inline const ::fsm::MN825_R168& MN::_internal_r168() const {
  return *r168_;
}
inline const ::fsm::MN825_R168& MN::r168() const {
  const ::fsm::MN825_R168* p = r168_;
  // @@protoc_insertion_point(field_get:fsm.MN.r168)
  return p != NULL ? *p : *reinterpret_cast<const ::fsm::MN825_R168*>(
      &::fsm::_MN825_R168_default_instance_);
}
inline ::fsm::MN825_R168* MN::release_r168() {
  // @@protoc_insertion_point(field_release:fsm.MN.r168)
  
  ::fsm::MN825_R168* temp = r168_;
  r168_ = NULL;
  return temp;
}
inline ::fsm::MN825_R168* MN::mutable_r168() {
  
  if (r168_ == NULL) {
    auto* p = CreateMaybeMessage<::fsm::MN825_R168>(GetArenaNoVirtual());
    r168_ = p;
  }
  // @@protoc_insertion_point(field_mutable:fsm.MN.r168)
  return r168_;
}
inline void MN::set_allocated_r168(::fsm::MN825_R168* r168) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete r168_;
  }
  if (r168) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      r168 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, r168, submessage_arena);
    }
    
  } else {
    
  }
  r168_ = r168;
  // @@protoc_insertion_point(field_set_allocated:fsm.MN.r168)
}

// repeated .fsm.MN_Channel channel = 3 [(.nanopb) = {
inline int MN::channel_size() const {
  return channel_.size();
}
inline void MN::clear_channel() {
  channel_.Clear();
}
inline ::fsm::MN_Channel* MN::mutable_channel(int index) {
  // @@protoc_insertion_point(field_mutable:fsm.MN.channel)
  return channel_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::fsm::MN_Channel >*
MN::mutable_channel() {
  // @@protoc_insertion_point(field_mutable_list:fsm.MN.channel)
  return &channel_;
}
inline const ::fsm::MN_Channel& MN::channel(int index) const {
  // @@protoc_insertion_point(field_get:fsm.MN.channel)
  return channel_.Get(index);
}
inline ::fsm::MN_Channel* MN::add_channel() {
  // @@protoc_insertion_point(field_add:fsm.MN.channel)
  return channel_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fsm::MN_Channel >&
MN::channel() const {
  // @@protoc_insertion_point(field_list:fsm.MN.channel)
  return channel_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace fsm

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::fsm::MNTypeDevice> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fsm::MNTypeDevice>() {
  return ::fsm::MNTypeDevice_descriptor();
}
template <> struct is_proto_enum< ::fsm::MN921TypeTCH> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fsm::MN921TypeTCH>() {
  return ::fsm::MN921TypeTCH_descriptor();
}
template <> struct is_proto_enum< ::fsm::MN921OutputCallFrequency> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fsm::MN921OutputCallFrequency>() {
  return ::fsm::MN921OutputCallFrequency_descriptor();
}
template <> struct is_proto_enum< ::fsm::MN921TypeATS> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fsm::MN921TypeATS>() {
  return ::fsm::MN921TypeATS_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_fsm_5fcckconfig_5fMN_2eproto
